"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CredentialMapper = void 0;
const types_1 = require("../types");
const jwt_decode_1 = __importDefault(require("jwt-decode"));
const utils_1 = require("../utils");
class CredentialMapper {
    static decodeVerifiablePresentation(presentation) {
        var _a;
        if (CredentialMapper.isJwtEncoded(presentation)) {
            const payload = (0, jwt_decode_1.default)(presentation);
            const header = (0, jwt_decode_1.default)(presentation, { header: true });
            payload.vp.proof = {
                type: types_1.IProofType.JwtProof2020,
                created: payload.nbf,
                proofPurpose: types_1.IProofPurpose.authentication,
                verificationMethod: (_a = header['kid']) !== null && _a !== void 0 ? _a : payload.iss,
                jwt: presentation,
            };
            return payload;
        }
        else if (CredentialMapper.isJwtDecodedPresentation(presentation)) {
            return presentation;
        }
        else if (CredentialMapper.isJsonLdAsString(presentation)) {
            return JSON.parse(presentation);
        }
        else {
            return presentation;
        }
    }
    static decodeVerifiableCredential(credential) {
        var _a;
        if (CredentialMapper.isJwtEncoded(credential)) {
            const payload = (0, jwt_decode_1.default)(credential);
            const header = (0, jwt_decode_1.default)(credential, { header: true });
            payload.vc.proof = {
                type: types_1.IProofType.JwtProof2020,
                created: payload.nbf,
                proofPurpose: types_1.IProofPurpose.authentication,
                verificationMethod: (_a = header['kid']) !== null && _a !== void 0 ? _a : payload.iss,
                jwt: credential,
            };
            return payload;
        }
        else if (CredentialMapper.isJwtDecodedCredential(credential)) {
            return credential;
        }
        else if (CredentialMapper.isJsonLdAsString(credential)) {
            return JSON.parse(credential);
        }
        else {
            return credential;
        }
    }
    static toWrappedVerifiablePresentation(originalPresentation, opts) {
        const original = originalPresentation;
        const isJwtEncoded = CredentialMapper.isJwtEncoded(original);
        const isJwtDecoded = CredentialMapper.isJwtDecodedPresentation(original);
        const type = isJwtEncoded ? types_1.OriginalType.JWT_ENCODED : isJwtDecoded ? types_1.OriginalType.JWT_DECODED : types_1.OriginalType.JSONLD;
        const format = isJwtDecoded || isJwtEncoded ? 'jwt_vp' : 'ldp_vp';
        const decoded = CredentialMapper.decodeVerifiablePresentation(original);
        let vp;
        if (isJwtEncoded || isJwtDecoded) {
            vp = CredentialMapper.jwtDecodedPresentationToUniformPresentation(decoded, false, opts);
        }
        else {
            vp = decoded;
        }
        if (!vp || !('verifiableCredential' in vp) || !vp.verifiableCredential || vp.verifiableCredential.length === 0) {
            throw Error(`VP needs to have at least one verifiable credential at this point`);
        }
        const vcs = CredentialMapper.toWrappedVerifiableCredentials(vp.verifiableCredential /*.map(value => value.original)*/, opts);
        const presentation = Object.assign(Object.assign({}, vp), { verifiableCredential: vcs });
        return {
            type,
            format,
            original,
            decoded,
            presentation,
            vcs,
        };
    }
    static toWrappedVerifiableCredentials(verifiableCredentials, opts) {
        return verifiableCredentials.map((vc) => CredentialMapper.toWrappedVerifiableCredential(vc, opts));
    }
    static toWrappedVerifiableCredential(verifiableCredential, opts) {
        const original = verifiableCredential;
        const decoded = CredentialMapper.decodeVerifiableCredential(verifiableCredential);
        const isJwtEncoded = CredentialMapper.isJwtEncoded(original);
        const isJwtDecoded = CredentialMapper.isJwtDecodedCredential(original);
        const type = isJwtEncoded ? types_1.OriginalType.JWT_ENCODED : isJwtDecoded ? types_1.OriginalType.JWT_DECODED : types_1.OriginalType.JSONLD;
        const credential = isJwtEncoded || isJwtDecoded
            ? CredentialMapper.jwtDecodedCredentialToUniformCredential(decoded, opts)
            : decoded;
        const format = isJwtEncoded || isJwtDecoded ? 'jwt_vc' : 'ldp_vc';
        return {
            original,
            decoded,
            format,
            type,
            credential,
        };
    }
    static isJwtEncoded(original) {
        return utils_1.ObjectUtils.isString(original) && original.startsWith('ey');
    }
    static isJsonLdAsString(original) {
        return utils_1.ObjectUtils.isString(original) && original.includes('@context');
    }
    static isJwtDecodedCredential(original) {
        return original['vc'] !== undefined && original['iss'] !== undefined;
    }
    static isJwtDecodedPresentation(original) {
        return original['vp'] !== undefined && original['iss'] !== undefined;
    }
    static jwtEncodedPresentationToUniformPresentation(jwt, makeCredentialsUniform = true, opts) {
        return CredentialMapper.jwtDecodedPresentationToUniformPresentation((0, jwt_decode_1.default)(jwt), makeCredentialsUniform, opts);
    }
    static jwtDecodedPresentationToUniformPresentation(decoded, makeCredentialsUniform = true, opts) {
        const presentation = Object.assign({}, (decoded.vp));
        if (makeCredentialsUniform) {
            if (!decoded.vp.verifiableCredential) {
                throw Error('Verifiable Presentation should have a verifiable credential at this point');
            }
            presentation.verifiableCredential = decoded.vp.verifiableCredential.map((vc) => CredentialMapper.toUniformCredential(vc, opts));
        }
        if (decoded.iss) {
            const holder = presentation.holder;
            if (holder) {
                if (holder !== decoded.iss) {
                    throw new Error(`Inconsistent holders between JWT claim (${decoded.iss}) and VC value (${holder})`);
                }
            }
            presentation.holder = decoded.iss;
        }
        if (decoded.jti) {
            const id = presentation.id;
            if (id && id !== decoded.jti) {
                throw new Error(`Inconsistent VP ids between JWT claim (${decoded.jti}) and VP value (${id})`);
            }
            presentation.id = decoded.jti;
        }
        return presentation;
    }
    static toUniformCredential(verifiableCredential, opts) {
        const original = verifiableCredential;
        const decoded = CredentialMapper.decodeVerifiableCredential(verifiableCredential);
        const isJwtEncoded = CredentialMapper.isJwtEncoded(original);
        const isJwtDecoded = CredentialMapper.isJwtDecodedCredential(original);
        if (isJwtDecoded || isJwtEncoded) {
            return CredentialMapper.jwtDecodedCredentialToUniformCredential(decoded, opts);
        }
        else {
            return decoded;
        }
    }
    static toUniformPresentation(presentation, opts) {
        var _a;
        const original = presentation;
        const decoded = CredentialMapper.decodeVerifiablePresentation(original);
        const isJwtEncoded = CredentialMapper.isJwtEncoded(original);
        const isJwtDecoded = CredentialMapper.isJwtDecodedPresentation(original);
        const uniformPresentation = isJwtEncoded || isJwtDecoded
            ? CredentialMapper.jwtDecodedPresentationToUniformPresentation(decoded, false)
            : decoded;
        uniformPresentation.verifiableCredential = (_a = uniformPresentation.verifiableCredential) === null || _a === void 0 ? void 0 : _a.map((vc) => CredentialMapper.toUniformCredential(vc, opts)); // We cast it because we IPresentation needs a VC. The internal Credential doesn't have the required Proof anymore (that is intended)
        return uniformPresentation;
    }
    static jwtEncodedCredentialToUniformCredential(jwt, opts) {
        return CredentialMapper.jwtDecodedCredentialToUniformCredential((0, jwt_decode_1.default)(jwt), opts);
    }
    static jwtDecodedCredentialToUniformCredential(decoded, opts) {
        const credential = Object.assign({}, (decoded.vc));
        const maxSkewInMS = (opts === null || opts === void 0 ? void 0 : opts.maxTimeSkewInMS) !== undefined ? opts.maxTimeSkewInMS : 999;
        if (decoded.exp) {
            const expDate = credential.expirationDate;
            const jwtExp = parseInt(decoded.exp.toString());
            // fix seconds to millisecond for the date
            const expDateAsStr = jwtExp < 9999999999 ? new Date(jwtExp * 1000).toISOString().replace(/\.000Z/, 'Z') : new Date(jwtExp).toISOString();
            if (expDate && expDate !== expDateAsStr) {
                const diff = Math.abs(new Date(expDateAsStr).getTime() - new Date(expDate).getTime());
                if (!maxSkewInMS || diff > maxSkewInMS) {
                    throw new Error(`Inconsistent expiration dates between JWT claim (${expDateAsStr}) and VC value (${expDate})`);
                }
            }
            credential.expirationDate = expDateAsStr;
        }
        if (decoded.nbf) {
            const issuanceDate = credential.issuanceDate;
            const jwtNbf = parseInt(decoded.nbf.toString());
            // fix seconds to millisecs for the date
            const nbfDateAsStr = jwtNbf < 9999999999 ? new Date(jwtNbf * 1000).toISOString().replace(/\.000Z/, 'Z') : new Date(jwtNbf).toISOString();
            if (issuanceDate && issuanceDate !== nbfDateAsStr) {
                const diff = Math.abs(new Date(nbfDateAsStr).getTime() - new Date(issuanceDate).getTime());
                if (!maxSkewInMS || diff > maxSkewInMS) {
                    throw new Error(`Inconsistent issuance dates between JWT claim (${nbfDateAsStr}) and VC value (${issuanceDate})`);
                }
            }
            credential.issuanceDate = nbfDateAsStr;
        }
        if (decoded.iss) {
            const issuer = credential.issuer;
            if (issuer) {
                if (typeof issuer === 'string') {
                    if (issuer !== decoded.iss) {
                        throw new Error(`Inconsistent issuers between JWT claim (${decoded.iss}) and VC value (${issuer})`);
                    }
                }
                else {
                    if (issuer.id !== decoded.iss) {
                        throw new Error(`Inconsistent issuers between JWT claim (${decoded.iss}) and VC value (${issuer.id})`);
                    }
                }
            }
            else {
                credential.issuer = decoded.iss;
            }
        }
        if (decoded.sub) {
            const subjects = Array.isArray(credential.credentialSubject) ? credential.credentialSubject : [credential.credentialSubject];
            for (let i = 0; i < subjects.length; i++) {
                const csId = subjects[i].id;
                if (csId && csId !== decoded.sub) {
                    throw new Error(`Inconsistent credential subject ids between JWT claim (${decoded.sub}) and VC value (${csId})`);
                }
                Array.isArray(credential.credentialSubject)
                    ? (credential.credentialSubject[i].id = decoded.sub)
                    : (credential.credentialSubject.id = decoded.sub);
            }
        }
        if (decoded.jti) {
            const id = credential.id;
            if (id && id !== decoded.jti) {
                throw new Error(`Inconsistent credential ids between JWT claim (${decoded.jti}) and VC value (${id})`);
            }
            credential.id = decoded.jti;
        }
        return credential;
    }
    static toExternalVerifiableCredential(verifiableCredential) {
        let proof;
        if (verifiableCredential.proof) {
            if (!verifiableCredential.proof.type) {
                throw new Error('Verifiable credential proof is missing a type');
            }
            if (!verifiableCredential.proof.created) {
                throw new Error('Verifiable credential proof is missing a created date');
            }
            if (!verifiableCredential.proof.proofPurpose) {
                throw new Error('Verifiable credential proof is missing a proof purpose');
            }
            if (!verifiableCredential.proof.verificationMethod) {
                throw new Error('Verifiable credential proof is missing a verification method');
            }
            proof = Object.assign(Object.assign({}, verifiableCredential.proof), { type: verifiableCredential.proof.type, created: verifiableCredential.proof.created, proofPurpose: verifiableCredential.proof.proofPurpose, verificationMethod: verifiableCredential.proof.verificationMethod });
        }
        return Object.assign(Object.assign({}, verifiableCredential), { type: verifiableCredential.type
                ? typeof verifiableCredential.type === 'string'
                    ? [verifiableCredential.type]
                    : verifiableCredential.type
                : ['VerifiableCredential'], proof });
    }
    static storedCredentialToOriginalFormat(credential) {
        const type = CredentialMapper.detectDocumentType(credential);
        if (typeof credential === 'string') {
            if (type === 0 /* DocumentFormat.JWT */) {
                return CredentialMapper.toCompactJWT(credential);
            }
            else if (type === 1 /* DocumentFormat.JSONLD */) {
                return JSON.parse(credential);
            }
        }
        return credential;
    }
    static storedPresentationToOriginalFormat(presentation) {
        const type = CredentialMapper.detectDocumentType(presentation);
        if (typeof presentation === 'string') {
            if (type === 0 /* DocumentFormat.JWT */) {
                return CredentialMapper.toCompactJWT(presentation);
            }
            else if (type === 1 /* DocumentFormat.JSONLD */) {
                return JSON.parse(presentation);
            }
        }
        return presentation;
    }
    static toCompactJWT(jwtDocument) {
        if (CredentialMapper.detectDocumentType(jwtDocument) !== 0 /* DocumentFormat.JWT */) {
            throw Error('Cannot convert non JWT credential to JWT');
        }
        if (typeof jwtDocument === 'string') {
            return jwtDocument;
        }
        let proof;
        if ('vp' in jwtDocument) {
            proof = jwtDocument.vp.proof;
        }
        else if ('vc' in jwtDocument) {
            proof = jwtDocument.vc.proof;
        }
        else {
            proof = Array.isArray(jwtDocument.proof) ? jwtDocument.proof[0].jwt : jwtDocument.proof.jwt;
        }
        if (!proof) {
            throw Error(`Could not get JWT from supplied document`);
        }
        return proof;
    }
    static detectDocumentType(document) {
        if (typeof document === 'string') {
            return this.isJsonLdAsString(document) ? 1 /* DocumentFormat.JSONLD */ : 0 /* DocumentFormat.JWT */;
        }
        const proofs = 'vc' in document ? document.vc.proof : 'vp' in document ? document.vp.proof : document.proof;
        const proof = Array.isArray(proofs) ? proofs[0] : proofs;
        if (proof.jwt) {
            return 0 /* DocumentFormat.JWT */;
        }
        else if (proof.type === 'EthereumEip712Signature2021') {
            return 2 /* DocumentFormat.EIP712 */;
        }
        return 1 /* DocumentFormat.JSONLD */;
    }
}
exports.CredentialMapper = CredentialMapper;
//# sourceMappingURL=credential-mapper.js.map