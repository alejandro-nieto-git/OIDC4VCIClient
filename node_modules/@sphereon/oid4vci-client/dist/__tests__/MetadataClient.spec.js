"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const oid4vci_common_1 = require("@sphereon/oid4vci-common");
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
const nock_1 = __importDefault(require("nock"));
const CredentialOfferClient_1 = require("../CredentialOfferClient");
const MetadataClient_1 = require("../MetadataClient");
const MetadataMocks_1 = require("./MetadataMocks");
describe('MetadataClient with IdentiProof Issuer should', () => {
    beforeAll(() => {
        nock_1.default.cleanAll();
    });
    afterEach(() => {
        nock_1.default.cleanAll();
    });
    it('succeed with OID4VCI and separate AS metadata', () => __awaiter(void 0, void 0, void 0, function* () {
        (0, nock_1.default)(MetadataMocks_1.IDENTIPROOF_ISSUER_URL).get(oid4vci_common_1.WellKnownEndpoints.OPENID4VCI_ISSUER).reply(200, JSON.stringify(MetadataMocks_1.IDENTIPROOF_OID4VCI_METADATA));
        (0, nock_1.default)(MetadataMocks_1.IDENTIPROOF_AS_URL).get(oid4vci_common_1.WellKnownEndpoints.OAUTH_AS).reply(200, JSON.stringify(MetadataMocks_1.IDENTIPROOF_AS_METADATA));
        (0, nock_1.default)(MetadataMocks_1.IDENTIPROOF_AS_URL).get(oid4vci_common_1.WellKnownEndpoints.OPENID_CONFIGURATION).reply(404);
        const metadata = yield MetadataClient_1.MetadataClient.retrieveAllMetadata(MetadataMocks_1.IDENTIPROOF_ISSUER_URL);
        expect(metadata.credential_endpoint).toEqual('https://issuer.research.identiproof.io/credential');
        expect(metadata.token_endpoint).toEqual('https://auth.research.identiproof.io/oauth2/token');
        expect(metadata.credentialIssuerMetadata).toMatchObject(MetadataMocks_1.IDENTIPROOF_OID4VCI_METADATA);
    }));
    it('succeed with OID4VCI and separate AS metadata from Initiation', () => __awaiter(void 0, void 0, void 0, function* () {
        (0, nock_1.default)(MetadataMocks_1.IDENTIPROOF_ISSUER_URL).get(oid4vci_common_1.WellKnownEndpoints.OPENID4VCI_ISSUER).reply(200, JSON.stringify(MetadataMocks_1.IDENTIPROOF_OID4VCI_METADATA));
        (0, nock_1.default)(MetadataMocks_1.IDENTIPROOF_AS_URL).get(oid4vci_common_1.WellKnownEndpoints.OAUTH_AS).reply(200, JSON.stringify(MetadataMocks_1.IDENTIPROOF_AS_METADATA));
        (0, nock_1.default)(MetadataMocks_1.IDENTIPROOF_AS_URL).get(oid4vci_common_1.WellKnownEndpoints.OPENID_CONFIGURATION).reply(404);
        const INITIATE_URI = 'openid-initiate-issuance://?issuer=https%3A%2F%2Fissuer.research.identiproof.io&credential_type=OpenBadgeCredential&pre-authorized_code=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJhOTUyZjUxNi1jYWVmLTQ4YjMtODIxYy00OTRkYzgyNjljZjAiLCJwcmUtYXV0aG9yaXplZCI6dHJ1ZX0.YE5DlalcLC2ChGEg47CQDaN1gTxbaQqSclIVqsSAUHE&user_pin_required=false';
        const initiation = yield CredentialOfferClient_1.CredentialOfferClient.fromURI(INITIATE_URI);
        const metadata = yield MetadataClient_1.MetadataClient.retrieveAllMetadata((0, oid4vci_common_1.getIssuerFromCredentialOfferPayload)(initiation.credential_offer));
        expect(metadata.credential_endpoint).toEqual('https://issuer.research.identiproof.io/credential');
        expect(metadata.token_endpoint).toEqual('https://auth.research.identiproof.io/oauth2/token');
        expect(metadata.credentialIssuerMetadata).toEqual(MetadataMocks_1.IDENTIPROOF_OID4VCI_METADATA);
    }));
    it('Fail without OID4VCI and only AS metadata (no credential endpoint)', () => __awaiter(void 0, void 0, void 0, function* () {
        (0, nock_1.default)(MetadataMocks_1.IDENTIPROOF_ISSUER_URL)
            .get(oid4vci_common_1.WellKnownEndpoints.OPENID4VCI_ISSUER)
            .reply(404, JSON.stringify({ error: 'does not exist' }));
        (0, nock_1.default)(MetadataMocks_1.IDENTIPROOF_ISSUER_URL)
            .get(oid4vci_common_1.WellKnownEndpoints.OPENID_CONFIGURATION)
            .reply(404, JSON.stringify({ error: 'does not exist' }));
        (0, nock_1.default)(MetadataMocks_1.IDENTIPROOF_ISSUER_URL)
            .get(oid4vci_common_1.WellKnownEndpoints.OAUTH_AS)
            .reply(404, JSON.stringify({ error: 'does not exist' }));
        yield expect(() => MetadataClient_1.MetadataClient.retrieveAllMetadata(MetadataMocks_1.IDENTIPROOF_ISSUER_URL, { errorOnNotFound: true })).rejects.toThrowError('Could not deduce the token_endpoint for https://issuer.research.identiproof.io');
    }));
    it('Fail with OID4VCI and no AS metadata', () => __awaiter(void 0, void 0, void 0, function* () {
        (0, nock_1.default)(MetadataMocks_1.IDENTIPROOF_ISSUER_URL).get(oid4vci_common_1.WellKnownEndpoints.OPENID4VCI_ISSUER).reply(200, JSON.stringify(MetadataMocks_1.IDENTIPROOF_OID4VCI_METADATA));
        (0, nock_1.default)(MetadataMocks_1.IDENTIPROOF_AS_URL)
            .get(oid4vci_common_1.WellKnownEndpoints.OPENID_CONFIGURATION)
            .reply(404, JSON.stringify({ error: 'does not exist' }));
        (0, nock_1.default)(MetadataMocks_1.IDENTIPROOF_AS_URL).get(oid4vci_common_1.WellKnownEndpoints.OAUTH_AS).reply(404, JSON.stringify({}));
        yield expect(() => MetadataClient_1.MetadataClient.retrieveAllMetadata(MetadataMocks_1.IDENTIPROOF_ISSUER_URL)).rejects.toThrowError('Issuer https://issuer.research.identiproof.io provided a separate authorization server https://auth.research.identiproof.io, but that server did not provide metadata');
    }));
    it('Fail if there is no token endpoint with errors enabled', () => __awaiter(void 0, void 0, void 0, function* () {
        (0, nock_1.default)(MetadataMocks_1.IDENTIPROOF_ISSUER_URL).get(oid4vci_common_1.WellKnownEndpoints.OPENID4VCI_ISSUER).reply(200, JSON.stringify(MetadataMocks_1.IDENTIPROOF_OID4VCI_METADATA));
        const meta = JSON.parse(JSON.stringify(MetadataMocks_1.IDENTIPROOF_AS_METADATA));
        delete meta.token_endpoint;
        (0, nock_1.default)(MetadataMocks_1.IDENTIPROOF_AS_URL).get(oid4vci_common_1.WellKnownEndpoints.OAUTH_AS).reply(200, JSON.stringify(meta));
        (0, nock_1.default)(MetadataMocks_1.IDENTIPROOF_AS_URL).get(oid4vci_common_1.WellKnownEndpoints.OPENID_CONFIGURATION).reply(404);
        yield expect(() => MetadataClient_1.MetadataClient.retrieveAllMetadata(MetadataMocks_1.IDENTIPROOF_ISSUER_URL, { errorOnNotFound: true })).rejects.toThrowError('Authorization Sever https://auth.research.identiproof.io did not provide a token_endpoint');
    }));
    it('Fail if there is no credential endpoint with errors enabled', () => __awaiter(void 0, void 0, void 0, function* () {
        const meta = JSON.parse(JSON.stringify(MetadataMocks_1.IDENTIPROOF_OID4VCI_METADATA));
        delete meta.credential_endpoint;
        (0, nock_1.default)(MetadataMocks_1.IDENTIPROOF_ISSUER_URL).get(oid4vci_common_1.WellKnownEndpoints.OPENID4VCI_ISSUER).reply(200, JSON.stringify(meta));
        (0, nock_1.default)(MetadataMocks_1.IDENTIPROOF_AS_URL).get(oid4vci_common_1.WellKnownEndpoints.OAUTH_AS).reply(200, JSON.stringify(MetadataMocks_1.IDENTIPROOF_AS_METADATA));
        (0, nock_1.default)(MetadataMocks_1.IDENTIPROOF_AS_URL).get(oid4vci_common_1.WellKnownEndpoints.OPENID_CONFIGURATION).reply(404);
        yield expect(() => MetadataClient_1.MetadataClient.retrieveAllMetadata(MetadataMocks_1.IDENTIPROOF_ISSUER_URL, { errorOnNotFound: true })).rejects.toThrowError('Could not deduce the credential endpoint for https://issuer.research.identiproof.io');
    }));
    it('Succeed with default value if there is no credential endpoint with errors disabled', () => __awaiter(void 0, void 0, void 0, function* () {
        (0, nock_1.default)(MetadataMocks_1.IDENTIPROOF_ISSUER_URL).get(oid4vci_common_1.WellKnownEndpoints.OPENID4VCI_ISSUER).reply(200, JSON.stringify(MetadataMocks_1.IDENTIPROOF_OID4VCI_METADATA));
        (0, nock_1.default)(MetadataMocks_1.IDENTIPROOF_AS_URL).get(oid4vci_common_1.WellKnownEndpoints.OAUTH_AS).reply(200, JSON.stringify(MetadataMocks_1.IDENTIPROOF_AS_METADATA));
        (0, nock_1.default)(MetadataMocks_1.IDENTIPROOF_AS_URL).get(oid4vci_common_1.WellKnownEndpoints.OPENID_CONFIGURATION).reply(404);
        const metadata = yield MetadataClient_1.MetadataClient.retrieveAllMetadata(MetadataMocks_1.IDENTIPROOF_ISSUER_URL);
        expect(metadata.credential_endpoint).toEqual('https://issuer.research.identiproof.io/credential');
    }));
    it('Succeed with no well-known endpoints and errors disabled', () => __awaiter(void 0, void 0, void 0, function* () {
        (0, nock_1.default)(MetadataMocks_1.IDENTIPROOF_ISSUER_URL).get(oid4vci_common_1.WellKnownEndpoints.OPENID4VCI_ISSUER).reply(404, {});
        (0, nock_1.default)(MetadataMocks_1.IDENTIPROOF_ISSUER_URL).get(oid4vci_common_1.WellKnownEndpoints.OAUTH_AS).reply(404, {});
        (0, nock_1.default)(MetadataMocks_1.IDENTIPROOF_ISSUER_URL).get(oid4vci_common_1.WellKnownEndpoints.OPENID_CONFIGURATION).reply(404, {});
        const metadata = yield MetadataClient_1.MetadataClient.retrieveAllMetadata(MetadataMocks_1.IDENTIPROOF_ISSUER_URL);
        expect(metadata.credential_endpoint).toEqual('https://issuer.research.identiproof.io/credential');
    }));
    it('Fail when specific well-known is not found with errors enabled', () => __awaiter(void 0, void 0, void 0, function* () {
        (0, nock_1.default)(MetadataMocks_1.IDENTIPROOF_ISSUER_URL).get(oid4vci_common_1.WellKnownEndpoints.OPENID4VCI_ISSUER).reply(404, {});
        (0, nock_1.default)(MetadataMocks_1.IDENTIPROOF_ISSUER_URL).get(oid4vci_common_1.WellKnownEndpoints.OAUTH_AS).reply(404, {});
        (0, nock_1.default)(MetadataMocks_1.IDENTIPROOF_ISSUER_URL).get(oid4vci_common_1.WellKnownEndpoints.OPENID_CONFIGURATION).reply(404, {});
        const metadata = MetadataClient_1.MetadataClient.retrieveWellknown(MetadataMocks_1.IDENTIPROOF_ISSUER_URL, oid4vci_common_1.WellKnownEndpoints.OPENID4VCI_ISSUER, { errorOnNotFound: true });
        yield expect(metadata).rejects.toThrowError('{"error": "not found"}');
    }));
});
describe('Metadataclient with Spruce Issuer should', () => {
    it('succeed with OID4VCI and separate AS metadata', () => __awaiter(void 0, void 0, void 0, function* () {
        (0, nock_1.default)(MetadataMocks_1.SPRUCE_ISSUER_URL).get(oid4vci_common_1.WellKnownEndpoints.OPENID4VCI_ISSUER).reply(200, JSON.stringify(MetadataMocks_1.SPRUCE_OID4VCI_METADATA));
        (0, nock_1.default)(MetadataMocks_1.SPRUCE_ISSUER_URL).get(oid4vci_common_1.WellKnownEndpoints.OPENID_CONFIGURATION).reply(404);
        (0, nock_1.default)(MetadataMocks_1.SPRUCE_ISSUER_URL).get(oid4vci_common_1.WellKnownEndpoints.OAUTH_AS).reply(404);
        const metadata = yield MetadataClient_1.MetadataClient.retrieveAllMetadata(MetadataMocks_1.SPRUCE_ISSUER_URL);
        expect(metadata.credential_endpoint).toEqual('https://ngi-oidc4vci-test.spruceid.xyz/credential');
        expect(metadata.token_endpoint).toEqual('https://ngi-oidc4vci-test.spruceid.xyz/token');
        expect(metadata.credentialIssuerMetadata).toEqual(MetadataMocks_1.SPRUCE_OID4VCI_METADATA);
    }));
    it('Fail without OID4VCI', () => __awaiter(void 0, void 0, void 0, function* () {
        (0, nock_1.default)(MetadataMocks_1.SPRUCE_ISSUER_URL)
            .get(/.*/)
            .times(3)
            .reply(404, JSON.stringify({ error: 'does not exist' }));
        yield expect(() => MetadataClient_1.MetadataClient.retrieveAllMetadata(MetadataMocks_1.SPRUCE_ISSUER_URL, { errorOnNotFound: true })).rejects.toThrowError('Could not deduce the token_endpoint for https://ngi-oidc4vci-test.spruceid.xyz');
    }));
});
describe('Metadataclient with Danubetech should', () => {
    it('succeed without OID4VCI and with OIDC metadata', () => __awaiter(void 0, void 0, void 0, function* () {
        (0, nock_1.default)(MetadataMocks_1.DANUBE_ISSUER_URL).get(oid4vci_common_1.WellKnownEndpoints.OPENID_CONFIGURATION).reply(200, JSON.stringify(MetadataMocks_1.DANUBE_OIDC_METADATA));
        (0, nock_1.default)(MetadataMocks_1.DANUBE_ISSUER_URL)
            .get(/.well-known\/.*/)
            .times(2)
            .reply(404, JSON.stringify({ error: 'does not exist' }));
        const metadata = yield MetadataClient_1.MetadataClient.retrieveAllMetadata(MetadataMocks_1.DANUBE_ISSUER_URL);
        expect(metadata.credential_endpoint).toEqual('https://oidc4vc.uniissuer.io/credential');
        expect(metadata.token_endpoint).toEqual('https://oidc4vc.uniissuer.io/token');
        expect(metadata.credentialIssuerMetadata).toEqual(MetadataMocks_1.DANUBE_OIDC_METADATA);
    }));
    it('Fail without OID4VCI', () => __awaiter(void 0, void 0, void 0, function* () {
        (0, nock_1.default)(MetadataMocks_1.SPRUCE_ISSUER_URL)
            .get(/.*/)
            .times(3)
            .reply(404, JSON.stringify({ error: 'does not exist' }));
        yield expect(() => MetadataClient_1.MetadataClient.retrieveAllMetadata(MetadataMocks_1.SPRUCE_ISSUER_URL, { errorOnNotFound: true })).rejects.toThrowError('Could not deduce the token_endpoint for https://ngi-oidc4vci-test.spruceid.xyz');
    }));
});
describe('Metadataclient with Walt-id should', () => {
    it('succeed without OID4VCI and with OIDC metadata', () => __awaiter(void 0, void 0, void 0, function* () {
        (0, nock_1.default)(MetadataMocks_1.WALT_ISSUER_URL).get(oid4vci_common_1.WellKnownEndpoints.OPENID4VCI_ISSUER).reply(200, JSON.stringify(MetadataMocks_1.WALT_OID4VCI_METADATA));
        (0, nock_1.default)(MetadataMocks_1.WALT_ISSUER_URL)
            .get(/.well-known\/.*/)
            .times(2)
            .reply(404, JSON.stringify({ error: 'does not exist' }));
        const metadata = yield MetadataClient_1.MetadataClient.retrieveAllMetadata(MetadataMocks_1.WALT_ISSUER_URL);
        expect(metadata.credential_endpoint).toEqual('https://jff.walt.id/issuer-api/oidc/credential');
        expect(metadata.token_endpoint).toEqual('https://jff.walt.id/issuer-api/oidc/token');
        expect(metadata.credentialIssuerMetadata).toEqual(MetadataMocks_1.WALT_OID4VCI_METADATA);
    }));
    it('Fail without OID4VCI', () => __awaiter(void 0, void 0, void 0, function* () {
        (0, nock_1.default)(MetadataMocks_1.WALT_ISSUER_URL)
            .get(/.*/)
            .times(4)
            .reply(404, JSON.stringify({ error: 'does not exist' }));
        yield expect(() => MetadataClient_1.MetadataClient.retrieveAllMetadata(MetadataMocks_1.WALT_ISSUER_URL, { errorOnNotFound: true })).rejects.toThrowError('Could not deduce the token_endpoint for https://jff.walt.id/issuer-api/oidc');
    }));
});
// Spruce gives back 404's these days, so test is disabled
describe.skip('Metadataclient with SpruceId should', () => {
    beforeAll(() => {
        nock_1.default.cleanAll();
    });
    afterEach(() => {
        nock_1.default.cleanAll();
    });
    it('succeed without OID4VCI and with OIDC metadata', () => __awaiter(void 0, void 0, void 0, function* () {
        /*nock(WALT_ISSUER_URL).get(WellKnownEndpoints.OPENID4VCI_ISSUER).reply(200, JSON.stringify(WALT_OID4VCI_METADATA));
    
        nock(WALT_ISSUER_URL)
          .get(/.well-known\/.*!/)
          .times(2)
          .reply(404, JSON.stringify({ error: 'does not exist' }));
    */
        const metadata = yield MetadataClient_1.MetadataClient.retrieveAllMetadata('https://ngi-oidc4vci-test.spruceid.xyz');
        expect(metadata.credential_endpoint).toEqual('https://ngi-oidc4vci-test.spruceid.xyz/credential');
        expect(metadata.token_endpoint).toEqual('https://ngi-oidc4vci-test.spruceid.xyz/token');
        expect(metadata.credentialIssuerMetadata).toEqual({
            issuer: 'https://ngi-oidc4vci-test.spruceid.xyz',
            credential_endpoint: 'https://ngi-oidc4vci-test.spruceid.xyz/credential',
            token_endpoint: 'https://ngi-oidc4vci-test.spruceid.xyz/token',
            jwks_uri: 'https://ngi-oidc4vci-test.spruceid.xyz/jwks',
            grant_types_supported: ['urn:ietf:params:oauth:grant-type:pre-authorized_code'],
            credentials_supported: {
                OpenBadgeCredential: {
                    formats: {
                        jwt_vc: {
                            types: ['VerifiableCredential', 'OpenBadgeCredential'],
                            cryptographic_binding_methods_supported: ['did'],
                            cryptographic_suites_supported: ['ES256', 'ES256K'],
                        },
                        ldp_vc: {
                            types: ['VerifiableCredential', 'OpenBadgeCredential'],
                            cryptographic_binding_methods_supported: ['did'],
                            cryptographic_suites_supported: ['Ed25519Signature2018'],
                        },
                    },
                },
            },
        });
    }));
});
//# sourceMappingURL=MetadataClient.spec.js.map