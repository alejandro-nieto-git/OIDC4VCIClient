"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const oid4vci_common_1 = require("@sphereon/oid4vci-common");
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
const nock_1 = __importDefault(require("nock"));
const OpenID4VCIClient_1 = require("../OpenID4VCIClient");
const MOCK_URL = 'https://server.example.com/';
describe('OpenID4VCIClient', () => {
    let client;
    beforeEach(() => __awaiter(void 0, void 0, void 0, function* () {
        (0, nock_1.default)(MOCK_URL).get(/.*/).reply(200, {});
        (0, nock_1.default)(MOCK_URL).get(oid4vci_common_1.WellKnownEndpoints.OAUTH_AS).reply(404, {});
        (0, nock_1.default)(MOCK_URL).get(oid4vci_common_1.WellKnownEndpoints.OPENID_CONFIGURATION).reply(404, {});
        (0, nock_1.default)(`${MOCK_URL}`).post('/v1/auth/par').reply(201, { request_uri: 'test_uri', expires_in: 90 });
        client = yield OpenID4VCIClient_1.OpenID4VCIClient.fromURI({
            createAuthorizationRequestURL: false,
            clientId: 'test-client',
            uri: 'openid-initiate-issuance://?issuer=https://server.example.com&credential_type=TestCredential',
        });
    }));
    afterEach(() => {
        nock_1.default.cleanAll();
    });
    it('should successfully retrieve the authorization code using PAR', () => __awaiter(void 0, void 0, void 0, function* () {
        client.endpointMetadata.credentialIssuerMetadata.pushed_authorization_request_endpoint = `${MOCK_URL}v1/auth/par`;
        client.endpointMetadata.credentialIssuerMetadata.authorization_endpoint = `${MOCK_URL}v1/auth/authorize`;
        const actual = yield client.createAuthorizationRequestUrl({
            authorizationRequest: {
                parMode: oid4vci_common_1.PARMode.REQUIRE,
                scope: 'openid TestCredential',
                redirectUri: 'http://localhost:8881/cb',
            },
        });
        expect(actual).toEqual('https://server.example.com/v1/auth/authorize?request_uri=test_uri');
    }));
    it('should fail when pushed_authorization_request_endpoint is not present', () => __awaiter(void 0, void 0, void 0, function* () {
        client.endpointMetadata.credentialIssuerMetadata.authorization_endpoint = `${MOCK_URL}v1/auth/authorize`;
        yield expect(() => client.createAuthorizationRequestUrl({
            authorizationRequest: {
                parMode: oid4vci_common_1.PARMode.REQUIRE,
                scope: 'openid TestCredential',
                redirectUri: 'http://localhost:8881/cb',
            },
        })).rejects.toThrow(Error('PAR mode is set to required by Authorization Server does not support PAR!'));
    }));
    it('should fail when authorization_details and scope are not present', () => __awaiter(void 0, void 0, void 0, function* () {
        yield expect(() => client.createAuthorizationRequestUrl({
            authorizationRequest: {
                parMode: oid4vci_common_1.PARMode.REQUIRE,
                redirectUri: 'http://localhost:8881/cb',
            },
        })).rejects.toThrow(Error('Could not create authorization details from credential offer. Please pass in explicit details'));
    }));
    it('should not fail when only authorization_details is present', () => __awaiter(void 0, void 0, void 0, function* () {
        client.endpointMetadata.credentialIssuerMetadata.pushed_authorization_request_endpoint = `${MOCK_URL}v1/auth/par`;
        client.endpointMetadata.credentialIssuerMetadata.authorization_endpoint = `${MOCK_URL}v1/auth/authorize`;
        const actual = yield client.createAuthorizationRequestUrl({
            authorizationRequest: {
                parMode: oid4vci_common_1.PARMode.REQUIRE,
                authorizationDetails: [
                    {
                        type: 'openid_credential',
                        format: 'ldp_vc',
                        credential_definition: {
                            '@context': ['https://www.w3.org/2018/credentials/v1', 'https://www.w3.org/2018/credentials/examples/v1'],
                            types: ['VerifiableCredential', 'UniversityDegreeCredential'],
                        },
                    },
                ],
                redirectUri: 'http://localhost:8881/cb',
            },
        });
        expect(actual).toEqual('https://server.example.com/v1/auth/authorize?request_uri=test_uri');
    }));
    it('should not fail when only scope is present', () => __awaiter(void 0, void 0, void 0, function* () {
        client.endpointMetadata.credentialIssuerMetadata.pushed_authorization_request_endpoint = `${MOCK_URL}v1/auth/par`;
        client.endpointMetadata.credentialIssuerMetadata.authorization_endpoint = `${MOCK_URL}v1/auth/authorize`;
        const actual = yield client.createAuthorizationRequestUrl({
            authorizationRequest: {
                parMode: oid4vci_common_1.PARMode.REQUIRE,
                scope: 'openid TestCredential',
                redirectUri: 'http://localhost:8881/cb',
            },
        });
        expect(actual).toEqual('https://server.example.com/v1/auth/authorize?request_uri=test_uri');
    }));
    it('should not fail when both authorization_details and scope are present', () => __awaiter(void 0, void 0, void 0, function* () {
        client.endpointMetadata.credentialIssuerMetadata.pushed_authorization_request_endpoint = `${MOCK_URL}v1/auth/par`;
        client.endpointMetadata.credentialIssuerMetadata.authorization_endpoint = `${MOCK_URL}v1/auth/authorize`;
        const actual = yield client.createAuthorizationRequestUrl({
            authorizationRequest: {
                parMode: oid4vci_common_1.PARMode.REQUIRE,
                authorizationDetails: [
                    {
                        type: 'openid_credential',
                        format: 'ldp_vc',
                        credential_definition: {
                            '@context': ['https://www.w3.org/2018/credentials/v1', 'https://www.w3.org/2018/credentials/examples/v1'],
                            types: ['VerifiableCredential', 'UniversityDegreeCredential'],
                        },
                    },
                ],
                scope: 'openid TestCredential',
                redirectUri: 'http://localhost:8881/cb',
            },
        });
        expect(actual).toEqual('https://server.example.com/v1/auth/authorize?request_uri=test_uri');
    }));
});
//# sourceMappingURL=OpenID4VCIClientPAR.spec.js.map