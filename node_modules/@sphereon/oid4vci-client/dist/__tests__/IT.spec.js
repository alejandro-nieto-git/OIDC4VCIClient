"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UNIT_TEST_TIMEOUT = void 0;
const oid4vci_common_1 = require("@sphereon/oid4vci-common");
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
const nock_1 = __importDefault(require("nock"));
const __1 = require("..");
const CredentialOfferClient_1 = require("../CredentialOfferClient");
const MetadataMocks_1 = require("./MetadataMocks");
exports.UNIT_TEST_TIMEOUT = 30000;
const ISSUER_URL = 'https://issuer.research.identiproof.io';
const jwt = {
    header: { alg: oid4vci_common_1.Alg.ES256, kid: 'did:example:ebfeb1f712ebc6f1c276e12ec21/keys/1', typ: 'openid4vci-proof+jwt' },
    payload: { iss: 'test-clientId', nonce: 'tZignsnFbp', jti: 'tZignsnFbp223', aud: ISSUER_URL },
};
describe('OID4VCI-Client should', () => {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    function proofOfPossessionCallbackFunction(_args, _kid) {
        return __awaiter(this, void 0, void 0, function* () {
            return 'ey.val.ue';
        });
    }
    beforeEach(() => {
        nock_1.default.cleanAll();
    });
    afterEach(() => {
        nock_1.default.cleanAll();
    });
    // Access token mocks
    const mockedAccessTokenResponse = {
        access_token: 'ey6546.546654.64565',
        authorization_pending: false,
        c_nonce: 'c_nonce2022101300',
        c_nonce_expires_in: 2025101300,
        interval: 2025101300,
        token_type: 'Bearer',
    };
    const mockedVC = 'eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCJ9.eyJ2YyI6eyJAY29udGV4dCI6WyJodHRwczovL3d3dy53My5vcmcvMjAxOC9jcmVkZW50aWFscy92MSIsImh0dHBzOi8vd3d3LnczLm9yZy8yMDE4L2NyZWRlbnRpYWxzL2V4YW1wbGVzL3YxIl0sImlkIjoiaHR0cDovL2V4YW1wbGUuZWR1L2NyZWRlbnRpYWxzLzM3MzIiLCJ0eXBlIjpbIlZlcmlmaWFibGVDcmVkZW50aWFsIiwiVW5pdmVyc2l0eURlZ3JlZUNyZWRlbnRpYWwiXSwiaXNzdWVyIjoiaHR0cHM6Ly9leGFtcGxlLmVkdS9pc3N1ZXJzLzU2NTA0OSIsImlzc3VhbmNlRGF0ZSI6IjIwMTAtMDEtMDFUMDA6MDA6MDBaIiwiY3JlZGVudGlhbFN1YmplY3QiOnsiaWQiOiJkaWQ6ZXhhbXBsZTplYmZlYjFmNzEyZWJjNmYxYzI3NmUxMmVjMjEiLCJkZWdyZWUiOnsidHlwZSI6IkJhY2hlbG9yRGVncmVlIiwibmFtZSI6IkJhY2hlbG9yIG9mIFNjaWVuY2UgYW5kIEFydHMifX19LCJpc3MiOiJodHRwczovL2V4YW1wbGUuZWR1L2lzc3VlcnMvNTY1MDQ5IiwibmJmIjoxMjYyMzA0MDAwLCJqdGkiOiJodHRwOi8vZXhhbXBsZS5lZHUvY3JlZGVudGlhbHMvMzczMiIsInN1YiI6ImRpZDpleGFtcGxlOmViZmViMWY3MTJlYmM2ZjFjMjc2ZTEyZWMyMSJ9.z5vgMTK1nfizNCg5N-niCOL3WUIAL7nXy-nGhDZYO_-PNGeE-0djCpWAMH8fD8eWSID5PfkPBYkx_dfLJnQ7NA';
    const INITIATE_QR = 'openid-initiate-issuance://?issuer=https%3A%2F%2Fissuer.research.identiproof.io&credential_type=OpenBadgeCredentialUrl&pre-authorized_code=4jLs9xZHEfqcoow0kHE7d1a8hUk6Sy-5bVSV2MqBUGUgiFFQi-ImL62T-FmLIo8hKA1UdMPH0lM1xAgcFkJfxIw9L-lI3mVs0hRT8YVwsEM1ma6N3wzuCdwtMU4bcwKp&user_pin_required=true';
    const OFFER_QR = 'openid-credential-offer://credential_offer=%7B%22credential_issuer%22:%22https://credential-issuer.example.com%22,%22credentials%22:%5B%7B%22format%22:%22jwt_vc_json%22,%22types%22:%5B%22VerifiableCredential%22,%22UniversityDegreeCredential%22%5D%7D%5D,%22issuer_state%22:%22eyJhbGciOiJSU0Et...FYUaBy%22%7D';
    function succeedWithAFullFlowWithClientSetup() {
        (0, nock_1.default)(MetadataMocks_1.IDENTIPROOF_ISSUER_URL).get('/.well-known/openid-credential-issuer').reply(200, JSON.stringify(MetadataMocks_1.IDENTIPROOF_OID4VCI_METADATA));
        (0, nock_1.default)(MetadataMocks_1.IDENTIPROOF_AS_URL).get('/.well-known/oauth-authorization-server').reply(200, JSON.stringify(MetadataMocks_1.IDENTIPROOF_AS_METADATA));
        (0, nock_1.default)(MetadataMocks_1.IDENTIPROOF_AS_URL).get(oid4vci_common_1.WellKnownEndpoints.OPENID_CONFIGURATION).reply(404, {});
        (0, nock_1.default)(MetadataMocks_1.IDENTIPROOF_AS_URL)
            .post(/oauth2\/token.*/)
            .reply(200, JSON.stringify(mockedAccessTokenResponse));
        (0, nock_1.default)(ISSUER_URL)
            .post(/credential/)
            .reply(200, {
            format: 'jwt-vc',
            credential: mockedVC,
        });
    }
    it('succeed with a full flow with the client using OpenID4VCI version 9', () => __awaiter(void 0, void 0, void 0, function* () {
        succeedWithAFullFlowWithClientSetup();
        const client = yield __1.OpenID4VCIClient.fromURI({
            uri: INITIATE_QR,
            kid: 'did:example:ebfeb1f712ebc6f1c276e12ec21/keys/1',
            alg: oid4vci_common_1.Alg.ES256,
            clientId: 'test-clientId',
        });
        yield assertionOfsucceedWithAFullFlowWithClient(client);
    }));
    test.skip('succeed with a full flow wit the client using OpenID4VCI version 11', () => __awaiter(void 0, void 0, void 0, function* () {
        succeedWithAFullFlowWithClientSetup();
        const client = yield __1.OpenID4VCIClient.fromURI({
            uri: OFFER_QR,
            kid: 'did:example:ebfeb1f712ebc6f1c276e12ec21/keys/1',
            alg: oid4vci_common_1.Alg.ES256,
            clientId: 'test-clientId',
        });
        yield assertionOfsucceedWithAFullFlowWithClient(client);
    }));
    function assertionOfsucceedWithAFullFlowWithClient(client) {
        return __awaiter(this, void 0, void 0, function* () {
            expect(client.credentialOffer).toBeDefined();
            expect(client.endpointMetadata).toBeDefined();
            expect(client.getIssuer()).toEqual('https://issuer.research.identiproof.io');
            expect(client.getCredentialEndpoint()).toEqual('https://issuer.research.identiproof.io/credential');
            expect(client.getAccessTokenEndpoint()).toEqual('https://auth.research.identiproof.io/oauth2/token');
            const accessToken = yield client.acquireAccessToken({ pin: '1234' });
            expect(accessToken).toEqual(mockedAccessTokenResponse);
            const credentialResponse = yield client.acquireCredentials({
                credentialTypes: 'OpenBadgeCredential',
                format: 'jwt_vc_json-ld',
                proofCallbacks: {
                    signCallback: proofOfPossessionCallbackFunction,
                },
            });
            expect(credentialResponse.credential).toEqual(mockedVC);
        });
    }
    it('succeed with a full flow without the client', () => __awaiter(void 0, void 0, void 0, function* () {
        var _a;
        /* Convert the URI into an object */
        const credentialOffer = yield CredentialOfferClient_1.CredentialOfferClient.fromURI(INITIATE_QR);
        expect(credentialOffer.baseUrl).toEqual('openid-initiate-issuance://');
        expect(credentialOffer.original_credential_offer).toEqual({
            credential_type: ['OpenBadgeCredentialUrl'],
            issuer: ISSUER_URL,
            'pre-authorized_code': '4jLs9xZHEfqcoow0kHE7d1a8hUk6Sy-5bVSV2MqBUGUgiFFQi-ImL62T-FmLIo8hKA1UdMPH0lM1xAgcFkJfxIw9L-lI3mVs0hRT8YVwsEM1ma6N3wzuCdwtMU4bcwKp',
            user_pin_required: 'true',
        });
        (0, nock_1.default)(ISSUER_URL)
            .post(/token.*/)
            .reply(200, JSON.stringify(mockedAccessTokenResponse));
        /* The actual access token calls */
        const accessTokenClient = new __1.AccessTokenClient();
        const accessTokenResponse = yield accessTokenClient.acquireAccessToken({ credentialOffer: credentialOffer, pin: '1234' });
        expect(accessTokenResponse.successBody).toEqual(mockedAccessTokenResponse);
        // Get the credential
        (0, nock_1.default)(ISSUER_URL)
            .post(/credential/)
            .reply(200, {
            format: 'jwt-vc',
            credential: mockedVC,
        });
        const credReqClient = __1.CredentialRequestClientBuilder.fromCredentialOffer({ credentialOffer: credentialOffer })
            .withFormat('jwt_vc')
            .withTokenFromResponse(accessTokenResponse.successBody)
            .build();
        //TS2322: Type '(args: ProofOfPossessionCallbackArgs) => Promise<string>'
        // is not assignable to type 'ProofOfPossessionCallback'.
        // Types of parameters 'args' and 'args' are incompatible.
        // Property 'kid' is missing in type '{ header: unknown; payload: unknown; }' but required in type 'ProofOfPossessionCallbackArgs'.
        const proof = yield __1.ProofOfPossessionBuilder.fromJwt({
            jwt,
            callbacks: {
                signCallback: proofOfPossessionCallbackFunction,
            },
            version: oid4vci_common_1.OpenId4VCIVersion.VER_1_0_11,
        })
            .withEndpointMetadata({
            issuer: 'https://issuer.research.identiproof.io',
            credential_endpoint: 'https://issuer.research.identiproof.io/credential',
            token_endpoint: 'https://issuer.research.identiproof.io/token',
        })
            .withKid('did:example:ebfeb1f712ebc6f1c276e12ec21/keys/1')
            .build();
        const credResponse = yield credReqClient.acquireCredentialsUsingProof({ proofInput: proof });
        expect((_a = credResponse.successBody) === null || _a === void 0 ? void 0 : _a.credential).toEqual(mockedVC);
    }), exports.UNIT_TEST_TIMEOUT);
});
//# sourceMappingURL=IT.spec.js.map